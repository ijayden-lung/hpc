#!/usr/bin/perl -w
#$|=1;

use threads;
use threads::shared;
use File::Basename;
use Data::Dumper;
#use strict;


my $core_uuid = $ARGV[0];
my $core_upload_dir = "../tmp";
#my $core_upload_dir = $ARGV[1];
#my $core_input_genome = $ARGV[2];

# deprecated - retained for compatibility issues
my $core_run_tally_flag = 'TRUE';
my $core_max_file_size_bypassing_bsub = 524288;
my $USE_FRACTIONAL_COUNTS_FOR_PARALOGS = 0;

# read run paramters from file
my %parameters_hash = ();
open(PARH, "$core_upload_dir/$core_uuid/parameters.log");
while(<PARH>){
	chomp;
	my @vals = split("\t", $_);
	if($#vals == 1){
		$parameters_hash{ $vals[0] } = $vals[1];
	} else{
		$parameters_hash{ $vals[0] } = 'NA';
	}

}
close(PARH);
#print FILEOUT Dumper(\%parameters_hash);

my $core_input_genome = $parameters_hash{'input_genome'};
my $TALLY_LENGTH_LOWER_THRES = $parameters_hash{'min_seq_length'};
my $TALLY_LENGTH_UPPER_THRES = $parameters_hash{'max_seq_length'};
my $ultra_fast_option = $parameters_hash{'ultra_fast_option'};


# redirect stdout to bsub.log
open (PROGRESS_FH,">>$core_upload_dir/$core_uuid/bsub.log");
select PROGRESS_FH;
#select STDERR;


print "Content-type:text/html\n\n";
print "<HTML>";
#print "<PRE>\n";



# *** Run Main Script ***
run_core_mirnovo_pipeline($core_uuid, $core_upload_dir, $core_input_genome, $core_run_tally_flag, $core_max_file_size_bypassing_bsub, $USE_FRACTIONAL_COUNTS_FOR_PARALOGS);


#print "</PRE>\n";
print "</HTML>\n";


my $core_jobs_num = -1;


sub timestamp{
	my $d=`date`;
	chomp($d);
	print STDERR "Mirnovo web-server: $d \n\n";
}


sub nice_size
{
    my $size = shift;
 
    my @sizes=qw( B KB MB GB TB PB);
    my $i = 0;
    
    while ($size > 1024)
    {
        $size = $size / 1024;
        $i++;
    }
    return sprintf("%.2f$sizes[$i]", $size);
}







sub run_core_mirnovo_pipeline{
    
    
    my $core_uuid = shift;
    my $core_upload_dir = shift;
    my $core_input_genome = shift;
    my $core_run_tally_flag = shift;
    my $core_max_file_size_bypassing_bsub = shift;
    my $USE_FRACTIONAL_COUNTS_FOR_PARALOGS = shift; 
    
    my $core_wd = "$core_upload_dir/$core_uuid";
    

    
    # Main job has been submitted to the cluster!
    #mkdir "$core_wd/logs/";
    #chmod(0777, "$core_wd/logs") or die "Couldn't chmod $core_wd/logs: $!";
    
    
    #my $submited_to_cluster_signal = "../tmp/".$core_uuid.".log";
    #open (SUBMITTED_TO_CLUSTER,'>', $submited_to_cluster_signal);
    #print SUBMITTED_TO_CLUSTER "submitted";
    #close(SUBMITTED_TO_CLUSTER);
    
    
    #mkdir "$core_wd/logs/";
    #chmod(0777, "$core_wd/logs") or die "Couldn't chmod $core_wd/logs: $!";
    #open (PROGRESS_FH,">$core_wd/logs/progress.log");
    
    
    my @core_input_files = glob "$core_wd/*.gz";
    my $core_num_of_files = $#core_input_files + 1;
    
    $core_jobs_num = $core_num_of_files;
    
    
    
    my $core_job_id = 0;
    
    my @core_file_threads = ();
    
    open(FILE_IDS_NAMES_FH, '>', "$core_wd/file_ids_names.csv");
    print FILE_IDS_NAMES_FH "ID,Name,Size\n";
    
    
    print "Overall process: started\n";
   
    #print "Split multi-mapped read counts equally to paralogs:"; 
    #if($USE_FRACTIONAL_COUNTS_FOR_PARALOGS == 0){
    #	print " FALSE\n\n";
    #} else{
    #	print " TRUE\n\n";
    #}



    foreach(@core_input_files){
        
        $core_job_id++;
        
        mkdir "$core_wd/$core_job_id";
        chmod(0777, "$core_wd/$core_job_id") or die "Couldn't chmod $core_wd/$core_job_id: $!";
        
        open(TMP_FILE_IDS_NAMES_FH, '>', "$core_wd/$core_job_id/file_ids_names.csv");
        print TMP_FILE_IDS_NAMES_FH "ID,Name,Size\n";
        
        my $core_cur_input_file = $_;
        #my $filesize = "-s $cur_input_file";
        
        my $core_filesize = (stat($core_cur_input_file))[7];
        
        my $core_last_slash = rindex($core_cur_input_file, "/") + 1;
        my $core_pure_input_filename = substr($core_cur_input_file, $core_last_slash);
        
        # feed mirmod_mapper_cgi.pl with a SINGLE file each time
        my $core_filename = $core_cur_input_file;
        
        
        my $core_filesize_in_mb = nice_size($core_filesize); 
        
        print FILE_IDS_NAMES_FH "$core_job_id,$core_pure_input_filename,$core_filesize_in_mb\n";
        print TMP_FILE_IDS_NAMES_FH "$core_job_id,$core_pure_input_filename,$core_filesize_in_mb\n";
        close(TMP_FILE_IDS_NAMES_FH);
        
        
        # start thread
        push @core_file_threads, threads->create( sub{
            
            
            my $core_tally_out_file = "$core_wd/tallied.$core_pure_input_filename";
	    my $core_reaper_out_file = "$core_wd/reapered.$core_pure_input_filename";           
 
                
		if($core_run_tally_flag eq "TRUE"){
                    #open(FOO_FH, ">$upload_dir/tally_debug");
                    #print FOO_FH "tally -i $filename -o $tally_out_file\n";
                 

			# *******************************************
			#  REAPER STEP: if there is an 'adapters' dir 
			# *******************************************
			my $adapter_dir = "../tmp/$core_uuid/adapters";
			if(-e $adapter_dir){

				$core_filename = "../tmp/$core_uuid/$core_pure_input_filename";
				
				my $common_adapter_seq = "";
				my $common_adapter_file = $adapter_dir."/common_adapter";
				my $adapters_file = $adapter_dir."/adapters_file.txt";

				if(-e $common_adapter_file){

					open my $file, '<', "$common_adapter_file"; 
					$common_adapter_seq = <$file>; 
					close $file;
		
	
				} elsif(-e $adapters_file){

					my $safe_filename_characters = "a-zA-Z0-9_.-";

					open(AFH, $adapters_file);
					while(<AFH>){
						chomp;

						my $ad_line = $_;
				
						my @ad_line_vals = split('\t', $ad_line);
						my $file_val = $ad_line_vals[0];
#						print "file_val: $file_val\n";
						my ( $name, $path, $extension ) = fileparse ( $file_val, '\..*' );


						$extension = substr($extension, rindex('\.', $extension)+1);
#						print "final extension: $extension\n";

#						print "name, path, extension: $name, $path, $extension\n\n";
						$name=~ tr/ /_/;
						$name=~ s/[^$safe_filename_characters]//g;


						my $type="";
						if ($extension=~ /GZ$/i){
							$type="gz";
						} elsif ($extension=~ /GZIP$/i){
							$type="gz";
						} elsif ($extension=~ /ZIP/i){
							$type="zip";
						}

						my $file_val_candidate = "$name.$type";

#						print "file_val_candidate: $file_val_candidate\n";

						if($file_val_candidate eq $core_pure_input_filename){
				
							$common_adapter_seq = $ad_line_vals[1];
							last;
						}	
					}
					close(AFH);

				}

				print "[$core_job_id] Reaper started for $core_pure_input_filename!\n";
				#print "reaper-16-098/src/reaper -i $core_filename -geom no-bc -3pa $common_adapter_seq -tabu \"\" -basename $core_reaper_out_file >/dev/null 2>&1";
				#
				#beta:
				## system("reaper-16-098/src/reaper -i $core_filename -geom no-bc -3pa $common_adapter_seq -tabu \"\" -clean-length 0 -mr-tabu 14/2/1 -3p-global 12/2/0 -3p-prefix 8/2/0/0 -3p-head-to-tail 1 -nnn-check 3/5   -basename $core_reaper_out_file >/dev/null 2>&1");
				
				# Consider the first 10nt from the adapter only
				# so that more sequences can be trimmed properly.
				system("reaper-16-098/src/reaper -i $core_filename -geom no-bc -3pa $common_adapter_seq -tabu \"\" -clean-length 0 -mr-tabu 14/2/1 -3p-global 12/2/0 -3p-prefix 8/2/0/0 -3p-head-to-tail 1 -nnn-check 3/5 -basename $core_reaper_out_file -tri 20 >/dev/null 2>&1");


				my $final_reapered_file_id = "$core_reaper_out_file.lane.clean.gz"; 						

				`rm -f $core_filename`;
                                `mv $final_reapered_file_id $core_filename`;	


			}	
	
	

		
		
			# *******************************************
			# *******************************************


 
			$core_filename = "../tmp/$core_uuid/$core_pure_input_filename"; 
                    
			my $header_line = `zcat < $core_filename | head -n 1`;
			my $is_fq = 1 if $header_line =~ /^@/;

		        $core_tally_out_file = "../tmp/$core_uuid/tallied.$core_pure_input_filename";

		    print "[$core_job_id] Tally started for $core_pure_input_filename!\n";

#	            print "core_filename: $core_filename, core_tally_out_file: $core_tally_out_file\n";
                    my $tally_output = system("reaper-16-098/src/tally -i $core_filename -o $core_tally_out_file -tri 20 -l $TALLY_LENGTH_LOWER_THRES -u $TALLY_LENGTH_UPPER_THRES --fasta-out -format '>trn_t%T_i%I_x%C%n%R%n' >/dev/null 2>&1");



		    my $tally_outfile_content = `zcat < $core_tally_out_file | head -n 10`;
 
		    if($tally_outfile_content ne ''){
 
			# if initial input was fastq file:

			my $conv_out = $core_tally_out_file;
			if($is_fq){
				$conv_out = `./conv_tallied_fq_to_fa.pl $core_tally_out_file`; 
			} 

			    my $conv_core_tally_out_file = $conv_out;	

			    # use tallied file to process and identify modifications
			    `rm -f $core_filename`;
			    `mv $conv_core_tally_out_file $core_filename`;

			    print "[$core_job_id] Tally complete for $core_pure_input_filename!\n\n";
		     } else{
			print "=======================\n";
			print "$core_pure_input_filename has already been tallied!\n";
			print "The process will continue execution normally.";
			print "\n=======================\n\n";

			# fasta seqs length filtering
			`gunzip -c $core_filename | awk 'BEGIN {RS = ">" ; ORS = ""} length(\$2) >= $TALLY_LENGTH_LOWER_THRES && length(\$2) <= $TALLY_LENGTH_UPPER_THRES {print ">"\$0}' > $core_filename.filtered`;
			`gzip $core_filename.filtered`;
			`mv $core_filename.filtered.gz $core_filename`; 
		     }
                } else{ # for already tallied files 
			# but with a '@.* (d+)' format instead of a
			# '>.*_x(d+)'
	
			$core_filename = "../tmp/$core_uuid/$core_pure_input_filename";

			my $header_line = `zcat < $core_filename | head -n 1`;
			#if(!($header_line =~ /^>/ && $header_line =~ /_x(d+)$/)){

			my $is_fq = 1 if $header_line =~ /^@/;

			if($is_fq){
				$conv_out = `./conv_tallied_fq_to_fa.pl $core_filename`;
	
				`rm -f $core_filename`;
				`mv $conv_out $core_filename`;

				`gunzip -c $core_filename | awk 'BEGIN {RS = ">" ; ORS = ""} length(\$2) >=$TALLY_LENGTH_LOWER_THRES && length(\$2) <= $TALLY_LENGTH_UPPER_THRES {print ">"\$0}' > $core_filename.filtered`;
				`gzip $core_filename.filtered`;
				`mv $core_filename.filtered.gz $core_filename`; 
			}	
		}
               
	    print "[$core_job_id] Length filtering: retaining only sequences with $TALLY_LENGTH_LOWER_THRES - $TALLY_LENGTH_UPPER_THRES nt\n\n";   


	    if($ultra_fast_option eq 'checked'){
	    	print "./ultra_fast_filter.pl $core_filename $core_upload_dir/$core_uuid\n";
		`./ultra_fast_filter.pl $core_filename $core_upload_dir/$core_uuid`;
		#print "ultra-fast output:\n$o\n";

	    }

	    print " *** Initialising core mirnovo algorithm... ***\n\n";
	    `./call_mirnovo_master.pl $core_uuid $core_job_id $core_input_genome $core_upload_dir/$core_uuid $USE_FRACTIONAL_COUNTS_FOR_PARALOGS $TALLY_LENGTH_LOWER_THRES $TALLY_LENGTH_UPPER_THRES $core_filename`;

        });
    }
    
    foreach (@core_file_threads) {
        $_->join();
    }
    close(FILE_IDS_NAMES_FH);

}


select STDOUT;
