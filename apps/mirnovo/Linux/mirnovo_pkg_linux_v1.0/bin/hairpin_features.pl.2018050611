#!/usr/bin/perl

# @ author: Stijn van Dongen
# #edit: Dimitris Vitsios

use strict;
use warnings;

# Mature miRNA sequence must be typed in lowercase.

my $foldings_input_file = $ARGV[0];

#my $seq="GTCTTTGTAACGTGCGAACAaagcagcactgtgcaactgtgtAGATGGTTGGCCCGAGCTGCGGTGACCAGGTGCCCACAGATGTGGGAAGCAGTGCTCTCCTAACTGAGGT";
#my $fold="..((((((.........)))))).((((((((.(((((((....)))))))(((...((....)).....))).(((((....)))))..))))))))..(((.....))).";


my @rec = ();


my @traits =
(  'loops-in-hairpin'
,  'mirna-bracket-discrepancy'
,  'bracket-mirna-fraction'
,  'hairpin-size-estimate'
,  'loop-size-estimate'
,  'loop-mirna-distance-estimate'
);

my %traits_short =
(  'loops-in-hairpin',            , 'n-loops'
,  'mirna-bracket-discrepancy'    , 'bkt-dis'
,  'bracket-mirna-fraction'       , 'bkt-fra'
,  'hairpin-size-estimate'        , 'hp-sz'
,  'loop-size-estimate'           , 'loop-sz'
,  'loop-mirna-distance-estimate' , 'neck-sz'
);


my @traits_short = map { $traits_short{$_} } @traits;

my %cache = ();


sub order_pair {
   return $_[0] < $_[1] ? (@_, 0) : (reverse(@_), 1);
}



sub score_result {
   my $r = shift;
   my $hp_default_size = 60;
   my $hp_size_deviant = $r->{'hairpin-size-estimate'} / $hp_default_size;
   $hp_size_deviant = 1/$hp_size_deviant if $hp_size_deviant > 1;
   my $n_loop = $r->{'loops-in-hairpin'};
   $n_loop = 5 if !$n_loop;

   return $r->{'mirna-bracket-discrepancy'}
      *   $r->{'bracket-mirna-fraction'}
      *   $hp_size_deviant
      *   -$r->{'minimum-free-energy'}/60
      *   (1/$n_loop) ** 0.33
      ;
}


my %othertype = qw(r l l r);


local $" = "\t";
#print "mir\tcohort\tfam\tletter\tarm\tmfe\tscore\t@traits_short\n";

open(FH, $foldings_input_file);

#while (<DATA>) {
while (<FH>) {
#while(<>){
   chomp;
   push @rec, $_;

   if (@rec == 3) {

      # dbg:
      #die "no mfe" unless $rec[2] =~ s/\s+\((\s*\S+\s*)\)$//;
      unless($rec[2] =~ s/\s+\((\s*\S+\s*)\)$//){
      	print STDOUT -1;
      	exit(0);
      }

      my $mfe = $1;

      my $name = $rec[0];
      $name =~ s/^>//;

      #die "no 3p5p or family number in $name" unless $name =~ /([0-9]+)([a-z]?)-([35]p)/;
      #my $fam = $1;
      #my $letter = $2;
      #my $arm = $3;

	# Redundant:
      # die "no 3p5p or family number in $name" unless $name =~ /.*-[35]p/;
      # my $arm = $1;

      my $result = assess_hairpin($name, $rec[1], $rec[2], $mfe);
      my $score  = score_result($result);
      my $type   = "real";

      # $name =~ s/_([rl])$// || die "no rl match in name $name";
      # my $type = $1;
      # die "$name has no type [have $type]" unless defined($othertype{$type});

      if ($name =~ s/_rand_\d+$//) {
         $type = "shuf";
      }

      # push @{$cache{$name}}, $result;

         # print "$name\t$type\t$fam\t$letter\t$arm\t$mfe\t$score\t";
         # local $, = "\t";
         # print map { $result->{$_} } @traits;
         # print "\n";

	 #print STDERR "$foldings_input_file\n";
         for my $k (keys %$result) {
	    #print STDERR "k: $k\n";
            next if $k eq 'landscape';
	    #print STDERR "result[k]: $result->{$k}\n";
	    if(defined($result->{$k})){
		    print STDOUT "$k=>$result->{$k}\n";
	    } else{
		    print STDOUT "$k=>NA\n";
	    }
         }
	 print STDOUT "score=>$score\n";
         #print "\n";

         if (0) {
            print STDERR "$name $type\n";
            local $, = ' ';
            print STDERR map { "$traits_short{$_}=$result->{$_}"; } @traits;
            print STDERR " score=$score\n";
            print STDERR "$rec[1]\n";
            print STDERR "$rec[2]\n";
            print STDERR $result->{landscape};
            print STDERR "-----\n\n";
         }
      @rec = ();
   }
}

close(FH);

sub assess_hairpin {

   my ($name, $seq, $fold, $mfe) = @_;
   my $loop_size = 1;

   my $frac_openclose = 0;
   my $frac_mirnabrackets = 0;
   my $hairpin_size = 100;
   my $n_loops = 10;

   my %map = ();

   # dbg:
   #$seq =~ /([a-z]+)/g || die "no mirna match in [$seq]";
   unless($seq =~ /([a-z]+)/g){
 	print STDOUT 'NA';
	exit(0);
   }

   my $mirna = $1;
   my $mirna_length = length($mirna);
   my $mirna_start = pos($seq)-length($mirna);
   my $mirna_end = $mirna_start + $mirna_length - 1;

   my $print_marker = ' ' x $mirna_start . '-' x $mirna_length . "\n";
   my $print_scape = "";

   # print "$mirna_start $mirna\n";
   # below could be done cheaper by a simple stack process.
   # oh well.

   my $canvas = $fold;

   while ($canvas =~ /\(/) {
      while ($canvas =~ /(\([#.]*\))/g) {
         my $pos = pos($canvas);
         my $len = length($1);
         substr($canvas, $pos-$len, $len) = '#' . '.' x ($len-2) . '#';
         # dbg:
	 #die "uggh $pos $len" if defined($map{$pos-$len}) || defined($map{$pos-1});
         if(defined($map{$pos-$len}) || defined($map{$pos-1})){
	 	print STDOUT 'NA';
		exit(0);
	 };
         $map{$pos-$len} = $pos-1;
         $map{$pos-1} = $pos-$len;
         # print "$canvas\n";
         pos($canvas) = $pos+$len;
      }
      my $tree = $canvas;
      $tree =~ s/\#/\|/g;
      $tree =~ s/[().]/ /g;
      $print_scape .= "$tree\n";
   }


   my @mirna_matches = grep { defined($map{$_}) } ($mirna_start..$mirna_end);

   my @mirna_brackets = map { substr($fold, $_, 1) } @mirna_matches;
   my @mirna_brackets_lft = grep { $_ eq '(' } @mirna_brackets;
   my @mirna_brackets_rgt = grep { $_ eq ')' } @mirna_brackets;

   goto DONE unless @mirna_brackets;

   my $frac1 = @mirna_brackets_lft / (@mirna_brackets_lft + @mirna_brackets_rgt);
   my $mirna_distant = (sort { $b->[0] <=> $a->[0] } map { [abs($map{$_} - $_), $_]; } @mirna_matches)[0];
   $hairpin_size = $mirna_distant->[0];

   my @fold_range = sort { $a <=> $b } ($mirna_distant->[1], $map{$mirna_distant->[1]});
   my $fold_string = substr($fold, $fold_range[0], $fold_range[1] - $fold_range[0]+1);
   $n_loops =()= $fold_string =~ /\([.]*\)/g;
   my $loopy_bit = "";
   my $majority_str = "";
   my ($n_bracket_majority, $n_bracket_minority, $n_dots, $mirna_nt_matched_start);

   if ($frac1 < 0.5) {
      # CLOSE/RIGHT case    ))) ) ) )) ) )
      $frac1 = 1 - $frac1;
      my @mirna_brackets_majority = grep { $_ > $map{$_} } @mirna_matches;
      $mirna_nt_matched_start = $mirna_brackets_majority[0];
      $loopy_bit = substr($fold, $map{$mirna_nt_matched_start}, $mirna_nt_matched_start - $map{$mirna_nt_matched_start}+1);
      $majority_str = ")";
      $n_bracket_majority = grep { substr($fold, $_, 1) eq ')' } @mirna_matches;
      $n_bracket_minority = grep { substr($fold, $_, 1) eq '(' } @mirna_matches;
      $n_dots = $mirna_length - $n_bracket_minority - $n_bracket_majority;
      # dbg2:
      #die "checksum error" unless $n_dots + $n_bracket_majority + $n_bracket_minority == length($mirna);
      unless($n_dots + $n_bracket_majority + $n_bracket_minority == length($mirna)){
	print STDOUT 'NA';
	exit(0);
      }
   }
   else {
      # OPEN/LEFT case     ((( ( ( (( ( (
      my @mirna_brackets_majority = grep { $_ < $map{$_} } @mirna_matches;
      $mirna_nt_matched_start = $mirna_brackets_majority[-1];
      $loopy_bit = substr($fold, $mirna_nt_matched_start, $map{$mirna_nt_matched_start} - $mirna_nt_matched_start+1);
      # dbg2:
      #die "strange loopiness $loopy_bit" unless $loopy_bit =~ /\(\.*\)/;
      unless($loopy_bit =~ /\(\.*\)/){
	print STDOUT 'NA';
	exit(0);
      }
      $majority_str = "(";
      $n_bracket_majority = grep { substr($fold, $_, 1) eq '(' } @mirna_matches;
      $n_bracket_minority = grep { substr($fold, $_, 1) eq ')' } @mirna_matches;
      $n_dots = $mirna_length - $n_bracket_minority - $n_bracket_majority;
      # dbg2:
      #die "checksum error" unless $n_dots + $n_bracket_majority + $n_bracket_minority == length($mirna);
      unless($n_dots + $n_bracket_majority + $n_bracket_minority == length($mirna)){
	print STDOUT 'NA';
	exit(0);
      }
   }

   my ($hairpin_start, $hairpin_end, $swap) = order_pair($mirna_distant->[1], $map{$mirna_distant->[1]});
   my $start_bracket = substr($fold, $mirna_distant->[1], 1);
   my ($start_bracket_offset, $stem_extension);
   if ($start_bracket eq '(') {
      $start_bracket_offset = $mirna_distant->[1] - $mirna_start;
      my $i = $mirna_distant->[1] - 1;
      while ($i >= 0 && substr($fold, $i, 1) =~ /[\.\(]/) {
         $i--;
      }
      $stem_extension = $mirna_start - $i - 1;
   }
   else {
      $start_bracket_offset = $mirna_end - $mirna_distant->[1];
      my $i = $mirna_distant->[1] + 1;
      while ($i < length($fold) && substr($fold, $i, 1) =~ /[\.\)]/) {
         $i++;
      }
      $stem_extension = $i - $mirna_end - 1;
   }
   $print_marker .= ' ' x $hairpin_start . '-' x ($hairpin_end - $hairpin_start+1) . "\n";
   $print_marker .= ' ' x $mirna_nt_matched_start . '-' x ($map{$mirna_nt_matched_start} - $mirna_nt_matched_start+1) . " (loopy bit)\n";
   $print_marker .= <<EOP;
start-bracket=$start_bracket
start_bracket_offset    $start_bracket_offset
mirna-bracket-majority  $n_bracket_majority
mirna-bracket-minority  $n_bracket_minority
mirna-free              $n_dots
n-loops                 $n_loops
stem-extension          $stem_extension
hairpin-size            $hairpin_size
EOP

   while ($loopy_bit =~ /\((\.*)\)/g) {
      $loop_size = length($1) if length($1) > $loop_size;
   }

   my $loop_distance = int((length($loopy_bit) - $loop_size - 2) / 2);    # -2 is becaues loopy bit includes 2 matching parenthesis from miRNA.

   $frac_openclose = $frac1;
   $frac_mirnabrackets = ($frac1 * @mirna_brackets) / length($mirna);


   # mm, need to know starting position in $mirna.
   # just get the most extreme position, and find its match.


   #  mirna-bracket-discrepancy: K / N  where N is total #brackets in the miRNA, and K is the number of 'majority' brackets
   #  (distinguishing two 'directions' of brackets).
   #     e.g.  (( (( )) (( ((  -> N == 10, K == 8.
   #  mirna-bracket-fraction: K / N where N is mirna length, and K is the number of 'majority' brackets.
   #  hairpin-size-estimate is the maximum distance between matching brackets for which one bracket
   #     lies in the miRNA (stijn-note: probably should only pick among the majority brackets, however,
   #     things that have severe issues with majority-bracket criterion will pbb do badly anyway).
   #  loops-in-hairpin: the number of times (..) is seen in the stretch defined by hairpin-size-estimate.
   #  loop-size-estimate: the longest stretch of (..) among the loops defined by hairping-size-estimate.
   #  loop-mirna-distance-estimate: the 'neck size' -- in an 'ideal' miRNA, the distance between the loop
   #     and the miRNA in the precursor, i.e. the length of the stem between miRNA and loop.
   #  landscape: visualisation of the bracket structure.
   DONE:
   return {
      'mirna-bracket-discrepancy'    =>   $frac_openclose,              # mmmmm; perhaps better just use base features below.
      'bracket-mirna-fraction'       =>   $frac_mirnabrackets,          # mmmmm. idem.
      'mirna-bracket-majority'       =>   $n_bracket_majority,
      'mirna-bracket-majority'       =>   $n_bracket_majority,
      'mirna-unmatched'              =>   $n_dots,
      'hairpin-size-estimate'        =>   $hairpin_size,
      'loops-in-hairpin'             =>   $n_loops,
      'loop-size-estimate'           =>   $loop_size,
      'loop-mirna-distance-estimate' =>   $loop_distance,
      'minimum-free-energy'          =>   $mfe,
      'landscape'                    =>   $print_marker # . $print_scape
   };
}

#__DATA__
#>mmu-1 MI0000556
#UUCACUGUGGGAugagguaguagguuguauaguuUUAGGGUCACACCCACCACUGGGAGAUAACUAUACAAUCUACUGUCUUUCCUAAGGUGAU
#.(((((.(((((.(((((((((((((((((((((.....(((...((((....)))).))))))))))))))))))))))))))))).))))). (-41.90)
#>mmu-2
#UGAGAUCAUUUUGAAAGCUGAUUuuagucgaaaguuuuacuagaguACUAGAGUCGAAAGUUUUACUUAGUCGAAAGUUUUACUAGAGUUACU
#...............((.((((((((((.((((.(((((((.(((((..(((........))))))))))).)))).)))))))))))))))) (-15.50)
