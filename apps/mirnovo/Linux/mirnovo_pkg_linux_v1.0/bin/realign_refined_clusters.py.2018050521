#!/usr/bin/env python

from sys import argv
from sys import exit
import os.path
import subprocess
import gzip
import random
import glob
import re
import Queue
import threading
import time

"""
-Re-Aligns seqs in each cluster with clustalo -> outp: nalignm.<>
"""



# global variable
exitFlag = 0

class clustaloMyThread (threading.Thread):
    def __init__(self, threadID, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.q = q
    def run(self):
    #    print "Starting " + str(self.threadID)
        realign_usearch_cluster_seqs(self.threadID, self.q)
    #    print "Exiting " + str(self.threadID)


def realign_usearch_cluster_seqs(threadID, q): #q = and index for the current 'dir'
    """dir: usearch output directory
       Finds all cluster files in dir (e.g. Cluster.0, singletones excluded); for each cluster,
       takes the seqs and realigns them with clustalo; realignments are stored
       in 'nalignm.<>' files
       ! only clusters with >= min_read_number reads will be realigned

    """

    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data_index = q.get()
            cur_cluster_file = cluster_files[data_index]
            queueLock.release()

            #print("%s processing %s: %s" % (threadID, data_index, cur_cluster_file))

            cur_alignm_file = cur_cluster_file
            cur_alignm_file = cur_alignm_file.replace("ref_alignm", "nalignm")
	    # dbg
            num_lines = sum(1 for line in open(cur_cluster_file))
            if num_lines > 2:
		    ##cmd = "util/clustalo --infile=%s --dealign --outfmt=fa --outfile=%s --wrap=100 --threads=4 --force 2>/dev/null" % (cur_cluster_file, cur_alignm_file)
		    cmd = "util/muscle -in %s -out %s -maxiters 1 -diags -quiet" % (cur_cluster_file, cur_alignm_file)
		    #print(cmd)
		    subprocess.check_call(cmd, shell=True)
		    cmd = "util/fasta_formatter -i %s -w 100 > %s.temp; mv %s.temp %s" % (cur_alignm_file, cur_alignm_file, cur_alignm_file, cur_alignm_file)
		    subprocess.check_call(cmd, shell=True)
	    else:
	    	    os.rename(cur_cluster_file, cur_alignm_file)

        else:
            queueLock.release()
        time.sleep(0.5)

    # depr
    #cmd = "ls %s | grep '^Cluster\.[0-9]*$' | while read x ; do util/clustalo --infile=%s/${x} --dealign --outfmt=fa --outfile=%s/$(echo $x | sed -e 's/Cluster/alignm/') ; done" % (dir, dir, dir)
    #subprocess.check_call(cmd, shell=True)




if __name__ == '__main__':

    usearch_dir = argv[1]
    job_id = argv[2]


    NUM_OF_THREADS = 40
    dir = usearch_dir


    # list all files to apply 'clustalo'
    global cluster_files
    cluster_files = glob.glob(dir + "/ref_alignm.*")
    queueLock = threading.Lock()
    workQueue = Queue.Queue(len(cluster_files))
    threads = []

    #print(cluster_files)
    #print("-----------")

    print("["+job_id+"]>> Aligning refined clusters using [muscle]...")


    for threadID in range(0, NUM_OF_THREADS):
        #print("threadID: "+str(threadID))
        thread = clustaloMyThread(threadID, workQueue)
        thread.start()
        threads.append(thread)

    # Fill the queue
    queueLock.acquire()
    for cluster_file_id in range(0, len(cluster_files)):
    	workQueue.put(cluster_file_id)
    queueLock.release()

    # Wait for queue to empty
    while not workQueue.empty():
    	pass

    # Notify threads it's time to exit
    exitFlag = 1

    # Wait for all threads to complete
    for t in threads:
        t.join()
    print("["+job_id+"]<< Refined clusters realignment [muscle] complete!\n")

    # cleanup: causes issues for large number of generated files
    #cmd = "rm -f " + usearch_dir +"/ref_alignm.*";
    #subprocess.check_call(cmd, shell=True)

    #cmd = "rm -f " + usearch_dir +"/Cluster.*";
    #subprocess.check_call(cmd, shell=True)

    #cmd = "rm -f " + usearch_dir +"/cluster.*";
    #subprocess.check_call(cmd, shell=True)

